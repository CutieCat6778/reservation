package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"revervation/backend/graph/model"
	"revervation/backend/repository"
	"time"

	"github.com/google/uuid"
)

// CreateReservation is the resolver for the createReservation field.
func (r *mutationResolver) CreateReservation(ctx context.Context, input model.NewReservation) (*model.LoginWithReservationResponse, error) {
	repo := repository.NewReservationRepository()
	emptyString := " "
	fmt.Println(input.FirstName)
	if input.FirstName == nil {
		fmt.Println("It is nil")
		input.FirstName = &emptyString
	}
	reservation := &model.Reservation{
		ID:          uuid.New().String(),
		FirstName:   input.FirstName,
		LastName:    input.LastName,
		PhoneNumber: input.PhoneNumber,
		Email:       input.Email,
		Amount:      input.Amount,
		CreatedAt:   time.Now().Local(),
		ReserveAt:   input.ReserveAt.Local(),
		Status:      model.ReservationStatusOpen,
		Notes:       input.Notes,
	}
	if err := repo.Create(reservation); err != nil {
		return nil, err
	}

	authService := repository.NewAuthService()

	token, err := authService.SignToken(reservation.ID)
	if err != nil {
		return nil, err
	}

	r.Resolver.broadcastUpdate(reservation, model.ReservationEventBroadcastCreated)
	response := model.LoginWithReservationResponse{Token: token, Reservation: reservation}
	return &response, nil
}

// UpdateReservation is the resolver for the updateReservation field.
func (r *mutationResolver) UpdateReservation(ctx context.Context, input model.UpdateReservation) (*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if user.ReservationID != input.ID && !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	reservation, err := repo.Update(input.ID, input.FirstName, input.LastName, input.Amount, input.ReserveAt, input.Notes, input.PhoneNumber, input.Email)
	if err != nil {
		return nil, err
	}
	r.Resolver.broadcastUpdate(reservation, model.ReservationEventBroadcastUpdated)
	return reservation, nil
}

// CancelReservation is the resolver for the cancelReservation field.
func (r *mutationResolver) CancelReservation(ctx context.Context, id string) (*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if user.ReservationID != id && !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	reservation, err := repo.UpdateStatus(id, model.ReservationStatusCanceled)
	if err != nil {
		return nil, err
	}
	r.Resolver.broadcastUpdate(reservation, model.ReservationEventBroadcastCanceled)
	return reservation, nil
}

// OpenReservation is the resolver for the openReservation field.
func (r *mutationResolver) OpenReservation(ctx context.Context, id string) (*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	reservation, err := repo.UpdateStatus(id, model.ReservationStatusOpen)
	if err != nil {
		return nil, err
	}
	r.Resolver.broadcastUpdate(reservation, model.ReservationEventBroadcastCreated)
	return reservation, nil
}

// ConfirmReservation is the resolver for the confirmReservation field.
func (r *mutationResolver) ConfirmReservation(ctx context.Context, id string) (*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	reservation, err := repo.UpdateStatus(id, model.ReservationStatusConfirmed)
	if err != nil {
		return nil, err
	}
	r.Resolver.broadcastUpdate(reservation, model.ReservationEventBroadcastConfirmed)
	return reservation, nil
}

// DeclineReservation is the resolver for the declineReservation field.
func (r *mutationResolver) DeclineReservation(ctx context.Context, id string) (*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	reservation, err := repo.UpdateStatus(id, model.ReservationStatusDeclined)
	if err != nil {
		return nil, err
	}
	r.Resolver.broadcastUpdate(reservation, model.ReservationEventBroadcastDeclined)
	return reservation, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (string, error) {
	auth := repository.NewAuthService()
	return auth.Login(username, password)
}

// LoginWithReservation is the resolver for the loginWithReservation field.
func (r *mutationResolver) LoginWithReservation(ctx context.Context, id string, lastName string) (*model.LoginWithReservationResponse, error) {
	auth := repository.NewAuthService()
	return auth.LoginWithReservation(id, lastName)
}

// SendMessageToReservation is the resolver for the sendMessageToReservation field.
func (r *mutationResolver) SendMessageToReservation(ctx context.Context, id string, content string) (bool, error) {
	repo := repository.NewReservationRepository()
	err := repo.SendMessageToReservation(id, content, r.mailer)
	if err != nil {
		return false, err
	}

	_, err = repo.UpdateStatus(id, model.ReservationStatusDeclined)
	if err != nil {
		return false, err
	}

	return true, err
}

// GetReservation is the resolver for the getReservation field.
func (r *queryResolver) GetReservation(ctx context.Context, filter model.ReservationFilter) ([]*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	return repo.GetByFilter(filter)
}

// GetAllReservation is the resolver for the getAllReservation field.
func (r *queryResolver) GetAllReservation(ctx context.Context) ([]*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	return repo.GetAll()
}

// GetReservationInfo is the resolver for the getReservationInfo field.
func (r *queryResolver) GetReservationInfo(ctx context.Context, date *time.Time) (*model.ReservationInfo, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	return repo.GetStats(date)
}

// GetReservationToday returns all reservations for today
func (r *queryResolver) GetReservationToday(ctx context.Context) ([]*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	now := time.Now()
	startOfDay := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
	endOfDay := startOfDay.Add(24 * time.Hour)

	filter := model.ReservationFilter{
		DateFrom: &startOfDay,
		DateTo:   &endOfDay,
	}
	return repo.GetByFilter(filter)
}

// GetReservationInfoToday returns stats for today
func (r *queryResolver) GetReservationInfoToday(ctx context.Context) (*model.ReservationInfo, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	now := time.Now()
	return repo.GetStats(&now)
}

// GetReservationBySequence is the resolver for the getReservationBySequence field.
func (r *queryResolver) GetReservationBySequence(ctx context.Context, sequence int32) ([]*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()

	// Base start time at 17:00 today
	now := time.Now()
	startOfDay := time.Date(now.Year(), now.Month(), now.Day(), 17, 0, 0, 0, time.UTC)

	// Calculate start and end of the sequence
	start := startOfDay.Add(time.Duration(sequence) * 30 * time.Minute)
	end := start.Add(30 * time.Minute)

	filter := model.ReservationFilter{
		DateFrom: &start,
		DateTo:   &end,
	}

	return repo.GetByFilter(filter)
}

// GetBigReservation is the resolver for the getBigReservation field.
func (r *queryResolver) GetBigReservation(ctx context.Context) ([]*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}

	amount := int32(5)

	repo := repository.NewReservationRepository()
	filter := model.ReservationFilter{
		Amount: &amount, // 5 or more persons
	}
	all, err := repo.GetAllByFilter(filter)
	if err != nil {
		return nil, err
	}

	var bigReservations []*model.Reservation
	for _, res := range all {
		if res.Amount >= 5 {
			bigReservations = append(bigReservations, res)
		}
	}

	return bigReservations, nil
}

// GetAllReservationWithFilter is the resolver for the getAllReservationWithFilter field.
func (r *queryResolver) GetAllReservationWithFilter(ctx context.Context, filter model.ReservationFilter) ([]*model.Reservation, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	repo := repository.NewReservationRepository()
	return repo.GetAllByFilter(filter)
}

// ReservationUpdated is the resolver for the reservationUpdated field.
func (r *subscriptionResolver) ReservationUpdated(ctx context.Context) (<-chan *model.ReservationEventPayload, error) {
	user := repository.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("Unauthenticated")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Unauthenticated")
	}
	id := uuid.New().String()
	ch := r.Resolver.subscribe(id)
	go func() {
		<-ctx.Done()
		r.Resolver.unsubscribe(id)
	}()
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
